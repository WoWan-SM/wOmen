# **Roadmap развития проекта Trading Agent**

## **Введение и текущий статус**

Статус: Pre-Alpha / Unstable  
Результат: Отрицательный PnL (Убыток превышает прибыль, комиссии съедают депозит).

### **Основные проблемы:**

1. **Технические ошибки:** Значения индикаторов NaN (особенно ADX).  
2. **Ошибки исполнения:** Отказы в выставлении ордеров (недостаточно средств, неверная лотность).  
3. **Отсутствие контекста:** Логи пишутся в файл, анализ причин входа/выхода затруднен.  
4. **Слабый Risk Management:** Статичные стопы/тейки не учитывают волатильность (ATR).

## **Этап 1: "Тушение пожаров" (Hotfixes & Stability)**

**Цель:** Бот должен перестать крашиться, сыпать ошибками в лог и открывать сделки на основе NaN.

### **1.1. Исправление расчета индикаторов (CRITICAL)**

* **Проблема:** В логах видно ADX=NaN. Это происходит из\-за запроса недостаточного количества свечей. Индикаторам типа ADX или EMA требуется "разгон". Если период 14, нужно минимум 28-50 свечей, чтобы устранить шум начальных значений.  
* **Решение:** В TinkoffMarketDataService увеличить количество запрашиваемых свечей с запасом (например, N\*3 или фиксировано 100-200 свечей).

### **1.2. Валидация данных перед решением**

* **Задача:** В TechnicalIndicatorService добавить проверку: если любой индикатор вернул NaN, Infinity или 0 (где не должно быть 0\) — запрещать торговлю по этому тикеру в текущем цикле.  
* **Логика:**  
  if (Double.isNaN(adx) || Double.isNaN(rsi)) return Signal.NEUTRAL;

### **1.3. Управление лотностью (Lot Size Management)**

* **Задача:** В логах есть ошибки исполнения ордеров. Тинькофф API оперирует лотами, а не штуками. Реализовать сервис InstrumentService, который кэширует информацию об инструменте (lot, minPriceIncrement).  
* **Логика:** При расчете количества для покупки: quantity \= (targetAmount / price) / lotSize. Всегда округлять вниз до целого лота.

### **1.4. Проверка баланса (Pre-flight Check)**

* **Задача:** Перед отправкой ордера POST /orders делать проверку свободного кэша.  
* **Решение:** Запросить баланс \-\> Если freeMoney \< tradeAmount \-\> Пропустить и записать в лог WARN.

## **Этап 2: "Черный ящик" (Detailed Database Logging)**

**Цель:** Записывать каждый шаг бота в MariaDB для анализа. Мы должны знать, ПОЧЕМУ бот решил купить или ПОЧЕМУ он решил НЕ покупать.

### **2.1. Подготовка MariaDB**

Используем JPA / Hibernate. Создаем структуру таблиц.

### **2.2. Схема БД (Сущности)**

#### **A. market\_snapshot (Снимок рынка)**

Записываем каждый раз, когда бот анализирует тикер (раз в минуту).

* id (UUID/Long)  
* timestamp  
* ticker  
* price\_close  
* rsi\_value  
* adx\_value  
* macd\_value  
* atr\_value  
* ema\_value

#### **B. trade\_decision (Лог принятия решений — САМОЕ ВАЖНОЕ)**

Здесь мы пишем результат работы стратегии, даже если сделка не открылась.

* id  
* snapshot\_id (FK на market\_snapshot)  
* decision (BUY, SELL, HOLD, IGNORE)  
* reason\_code (например: "RSI\_OVERSOLD", "FILTERED\_BY\_ADX", "NO\_MONEY")  
* reason\_details (текст: "RSI=25\<30 but ADX=12\<20")

#### **C. orders (Исполнение)**

* id (внутренний)  
* broker\_order\_id (от Тинькофф)  
* ticker  
* direction (BUY/SELL)  
* requested\_price  
* executed\_price  
* quantity\_lots  
* commission  
* status (NEW, FILLED, REJECTED)  
* error\_message (если REJECTED)

#### **D. positions (Учет позиций)**

Для отслеживания PnL.

* id  
* entry\_order\_id  
* exit\_order\_id  
* entry\_price  
* exit\_price  
* pnl\_absolute  
* pnl\_percent  
* duration\_seconds

### **2.3. Реализация**

Внедрить Spring Data JPA. Заменить System.out.println и логгеры на auditService.save(...).

## **Этап 3: Рефакторинг Логики (Strategy & Architecture)**

**Цель:** Уйти от "спагетти-кода" к модульной архитектуре.

### **3.1. Переход на State Machine (Конечный автомат)**

Сейчас логика линейна. Нужно разделить состояния для каждого тикера:

1. **SCANNING:** Ищем точку входа.  
2. **ENTRY\_PENDING:** Ордер отправлен, ждем исполнения.  
3. **ACTIVE:** В позиции. Мониторим SL/TP.  
4. **EXIT\_PENDING:** Ордер на выход отправлен.  
5. **COOLDOWN:** После убытка или сделки не торгуем этот тикер N минут.

### **3.2. Динамический Риск-менеджмент**

Статичные 2% SL / 4% TP убыточны на волатильном рынке.

* **ATR Based SL/TP:**  
  * Стоп-лосс \= EntryPrice \- (ATR \* 2\)  
  * Тейк-профит \= EntryPrice \+ (ATR \* 3\)  
* **Trailing Stop:** Если цена ушла в плюс на 1 \* ATR, переносим Стоп в безубыток.

### **3.3. Фильтрация "Пилы" (Choppy Market)**

Текущие индикаторы (RSI/MACD) сливают во флете.

* **Фильтр:** Если ADX \< 25 \-\> Запрет на вход по трендовым стратегиям.  
* **Фильтр спреда:** Если (Ask \- Bid) / Bid \> 0.05% (большой спред) \-\> Не входим (комиссия съест прибыль).

## **Этап 4: Развитие (Evolution)**

### **4.1. Backtesting (Тестирование на истории)**

Прежде чем запускать на реальные деньги:

* Скачать историю свечей за год в БД.  
* Написать класс BacktestEngine, который "прогоняет" TechnicalIndicatorService по историческим данным и симулирует сделки без отправки в API.

### **4.2. UI Dashboard**

Подключить Grafana к MariaDB или написать простой фронт (React/Thymeleaf), чтобы видеть графики баланса и открытые позиции в реальном времени, а не в Excel.

### **4.3. Telegram Bot Notification**

Отправлять уведомления в Telegram:

* "Купил SBER по 250"  
* "ERROR: Не хватает денег"  
* "Daily Report: PnL \-50 rub"

## **Итоговый приоритет задач (Action Plan)**

1. \[CODE\] **Fix NaN in Indicators** (увеличить историю свечей).  
2. \[CODE\] **Fix Order Size logic** (учет лотности инструмента).  
3. \[INFRA\] **Поднять MariaDB \+ Spring Data JPA.**  
4. \[CODE\] **Реализовать логирование Snapshot и Decision.**  
5. \[ANALYTICS\] **Запустить бота на 24 часа** на "бумажном" счете (Sandbox) и проанализировать таблицу trade\_decision.  
6. \[STRATEGY\] **Внедрить ATR Trailing Stop.**